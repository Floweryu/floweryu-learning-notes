# 1. CAS简介

CAS：`Compare And Swap`，即比较再交换。

它是一条 CPU 并发原语。原语的执行必须是连续的，在执行过程中不允许中断，也就是说CAS是一条原子指令，不会造成所谓的数据不一致的问题。

它的实现借助了一个叫做`Unsafe`的类。`Unsafe`类是 Java 中用于直接操作内存数据的一个类（类似于C语言中的指针操作），其中包含很多的本地方法(native)。

# 2. CAS算法理解

CAS包含三个参数`v, E, N`，其中`V`表示要更新的变量，`E`表示预期值，`N`表示新值。仅当`V = E`时，才会设置`V`的值为`N`. 如果`V`和`E`的值不同，说明已经有了其它线程做了更新，则当前线程什么也不做。最后，CAS会返回当前`V`的真实值。

CAS操作是抱着乐观的态度进行的，它总是认为自己可以成功的完成操作。当多个线程同时使用CAS操作一个变量时，只有一个会胜出，并成功更新，其余均会失败。失败的线程不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。

# 3. CAS的缺点

## 3.1 ABA问题

因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新。

如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化。但是实际上却变化了。

**解决方案：**

- 使用**版本号机制**，如手动增加版本号字段。
- Java 1.5开始，JDK的`Atomic`包里提供了一个类`AtomicStampedReference`来解决ABA问题。这个类的`compareAndSet`方法的作用是首先**检查当前引用是否等于预期引用**，并且**检查当前的标志是否等于预期标志**，如果**全部相等**，则以原子方式将该应用和该标志的值设置为给定的更新值。

## 3.2 循环时间长开销大

自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。

**解决方案：**

- 破坏掉for死循环，当超过一定时间或者一定次数时，return退出。

## 3.3 只能保证一个共享变量的原子操作

当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性。

**解决方案**：

- 用锁
- 把多个共享变量合并成一个共享变量来操作。比如，有两个共享变量`i=2,j=a`,合并一下`ji=2a`,然后用CAS来操作`ij`。
- 封装成对象。注：从Java 1.5开始，JDK提供了AtomicReference类来保证引用对象之前的原子性，可以把多个变量放在一个对象里来进行CAS操作。

# 4. 参考资料

- [深入理解CAS算法原理](https://segmentfault.com/a/1190000021653471)

- 《实战Java高并发程序设计》

  