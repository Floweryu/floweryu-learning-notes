## 概念

Netty接收端可能会遇到一下几种情况：

1. 读取到一个完整的客户端输入ByteBuf，称为全包
2. 读到多个输入ByteBuf，称为粘包
3. 读到部分ByteBuf内容，并且有乱码，称为半包

粘包和半包可统称为**半包问题**

![image-20220526113832153](https://raw.githubusercontent.com/Floweryu/typora-img/main/img/202205261138970.png)

## 半包的原理

底层网络是以二进制字节报文形式传输数据的。

**读数据过程**：Netty先将二进制数据读取到ByteBuf缓冲区中，然后再转换为POJO对象。

**写数据过程**：将Java类型的数据转化为底层能够传输的二进制ByteBuf数据。

在发送端，Netty以ByteBuf为单位来发送数据，但是到了操作系统的内核缓冲区，底层会按照协议的规范对数据包进行二次包装，包装成传输层TCP的协议报文，再进行发送。

在接收端收到传输层的二进制数据后，首先保存在内核缓冲区中，Netty读取ByteBuf时才复制到进程缓冲区。这时就会出现下面问题：

- 每次读取TCP底层缓冲的数据容量是有限制的，当TCP底层缓冲的数据包比较大时，会将一个底层包分成多次ByteBuf进行复制，进而造成进程缓冲区读到的是半包。

- 当TCP底层缓冲的数据包比较小时，一次复制的却不止一个内存缓冲区包，进而造成进程缓冲区读到的是粘包。

**解决方法**

在接收端，Netty程序需要根据自定义协议，将读取到的进程缓冲区ByteBuf，在应用层进行二次拼装，重新组装应用层数据包。这个过程叫做**分包或者拆包**

分包有两种方法：

- 自定义解码器分包器：基于ByteToMessageDecoder或者ReplayingDecoder，定义自己的进程缓冲区分包器。
- 使用Netty内置的解码器。比如LengthFieldBasedFrameDecoder自定义分隔符数据包解码器，对进程缓冲区ByteBuf进行正确的分包。

