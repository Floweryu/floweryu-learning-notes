# 1. 哈希索引

哈希索引基于哈希表实现，**只有精确匹配索引所有列得查询才有效**。对于每一行数据，存储引擎都会对所有列计算一个哈希码，哈希码是一个较小得值，并且不同键值的行计算的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。

# 2. 哈希索引查询过程

看下面这个例子：

<img src="https://raw.githubusercontent.com/Floweryu/typora-img/main/img/20210727204047.png" alt="image-20210727203630216" style="zoom: 50%;" />

表中包含一下数据：

<img src="https://raw.githubusercontent.com/Floweryu/typora-img/main/img/20210727204045.png" alt="image-20210727203733500" style="zoom:50%;" />

假设索引使用哈希函数`f()`，它返回下面的值：

<img src="https://raw.githubusercontent.com/Floweryu/typora-img/main/img/20210727204138.png" alt="image-20210727204130079" style="zoom:50%;" />

则哈希索引的数据结构如下：

<img src="https://raw.githubusercontent.com/Floweryu/typora-img/main/img/20210727204224.png" alt="image-20210727204222982" style="zoom:50%;" />

下面看看下面查询：

```mysql
mysql> SELECT lname FROM testhash WHERE fname='Peter';`
```

MySQL先计算`Peter`的哈希值，并使用该值寻找对应的记录指针。因为`f('Peter')=8784`，所以MySQL在索引中查找8784，可以找到指向第3行的指针，最后一步是比较第三行的值是否为`Peter`，以确保就是要查找的行。

# 3. 哈希索引的限制

- 哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。
- 哈希索引数据并不是按照索引值的顺序存储的，所以也就无法使用排序。
- 哈希索引也不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的内容来计算哈希值的。例如：在数据列（A, B）上建立哈希索引，如果查询只有数据列A，则无法使用该索引。
- 哈希索引只支持等值比较查询，包括`=、IN()、<=>(<>和<=>是不同的操作)`，也不支持任何范围查询，例如`WHERE price > 30`。
- 访问哈希索引的数据非常快，除非有很多哈希冲突（不同的索引值却有相同的哈希值）。当哈希冲突出现的时候，存储引擎必须遍历链表中的所有行指针，逐行进行比较，直到找到所有符合条件的行。
- 如果哈希冲突很多的话，一些索引维护操作的代价也会很高。例如，如果在某个选择性很低(哈希冲突很多)的列上建立哈希索引，那么当从表中删除一行时，存储引擎需要遍历对应哈希值的链表的每一行，找到并删除对应行的应用，冲突越多，代价越大。



InnoDB可以创建**自适应哈希索引**。当某些索引值被使用的非常频繁时，会在内存中基于B-Tree索引之上再创建一个哈希索引，这样就让B-Tree索引也具有哈希索引的一些优点。

> 可以对一些字符串列自定义Hash索引，额外设置一个hash列，这个hash列可以作为字符串的哈希索引。这样在查询时可以使用下面这种方式进行查询：
>
> <img src="https://raw.githubusercontent.com/Floweryu/typora-img/main/img/20210729164825.png" alt="image-20210729164812866" style="zoom:50%;" />
>
> 这样数据库会先走索引查询记录，但由于可能索引会产生冲突，所以又添加了常量判断来保证查询结果正确。