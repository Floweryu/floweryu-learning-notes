# 1. 独立的列

独立的列是指**索引列不能是表达式的一部分，也不能是函数的参数**。

下面SQL查询都无法使用索引：

```mysql
SELECT id FROM user WHERE id + 1 = 5;
SELECT ... WHERE DAYS(date) - DAYS(col) <= 10;
```

# 2. 前缀索引和索引选择性

> 有时候需要索引很长的字符列，这会让索引变得大且慢。一个策略是使用模拟哈希索引。

可以索引开始的部分字符，提高查询效率，节约索引空间。但会降低索引的选择性。

> **索引的选择性：**
>
> 不重复的索引值(也称基数)和数据表的记录总数(T)的比值。范围在$1/T$到$1$​之间。
>
> 索引的选择行越高则查询的效率越高，因为选择性高的索引可以让MySQL在查找时过滤掉更多的行。
>
> 唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。

对于`BLOB, TEXT, 或很长的VARCHAR`类型列，必须使用前缀索引。

## 如何寻找最合适的前缀长度？

假设生成下面表：

```mysql
CREATE TABLE sakila.city_demo(city VARCHAR(50) NOT NULL);
INSERT INTO sakila.city_demo(city) SELECT city FROM sakila.city;
-- Repeat the next statement five times:
INSERT INTO sakila.city_demo(city) SELECT city FROM sakila.city_demo;
-- Now randomize the distribution (inefficiently but conveniently):
UPDATE sakila.city_demo
 SET city = (SELECT city FROM sakila.city ORDER BY RAND() LIMIT 1);
```

寻找最常见的城市如下：

```mysql
mysql> SELECT COUNT(*) AS cnt, city
 -> FROM sakila.city_demo GROUP BY city ORDER BY cnt DESC LIMIT 10;
+-----+----------------+
| cnt | city |
+-----+----------------+
| 65 | London |
| 49 | Hiroshima |
| 48 | Teboksary |
| 48 | Pak Kret |
| 48 | Yaound |
| 47 | Tel Aviv-Jaffa |
| 47 | Shimoga |
| 45 | Cabuyao |
| 45 | Callao |
| 45 | Bislig |
+-----+----------------+
```

上面每个city都出现了45~65次，