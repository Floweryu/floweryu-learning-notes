## 一、缓存的查询

先查询缓存，如果缓存查询失败，就去查询数据库，然后重新生成缓存。

## 二、缓存的更新

在高并发的情况下，需要考虑下面两个问题：

- 是先更新数据库还是先更新缓存？
- 是更新缓存还是删除缓存？

#### 1. 先更新数据库再更新缓存

线程A：更新数据库（第1s）——>  更新缓存（第10s）

线程B：更新数据库 （第3s）——> 更新缓存（第5s）

上面情况，就会导致线程B的缓存值被线程A覆盖，**缓存中存的是线程A的旧值**，产生脏数据并且直到缓存失效（如果有过期时间）。

<img src="./assets/image-20230619124741669.png" alt="image-20230619124741669" style="zoom: 33%;" />

#### 2. 先更新缓存再更新数据库

线程A：更新缓存（第1s）——> 更新数据库（第10s）

线程B： 更新缓存（第3s）——>  更新数据库（第5s）

和前面一种情况相反，**缓存中是线程B的新值，而数据库中是线程A的旧值。**

<img src="./assets/image-20230619124959400.png" alt="image-20230619124959400" style="zoom:33%;" />

﻿前两种方式之所以会在并发场景下出现异常，**本质上是因为更新缓存和更新数据库是两个操作**。

如果把它化简，更新时只更新数据库，同时删除缓存。等待下一次查询时命中不到缓存，再去重建缓存，是不是就解决了这个问题？

#### 3. 先删除缓存再更新数据库

通过这种方式，两个线程都值修改数据库，不管谁先，数据库以后修改的数据为准。

但这时另一个**并发场景**：两个并发操作，一个是更新操作，另一个是查询操作，更新操作删除缓存后，查询操作没有命中缓存，先把老数据读出来后放到缓存中，然后更新操作更新了数据库。于是，在缓存中的数据还是老的数据，导致缓存中的数据是脏的。很显然，这种状况也不是我们想要的。

<img src="./assets/image-20230619125515058.png" alt="image-20230619125515058" style="zoom:33%;" />

**解决方案**：

##### 延时双删

对于**请求**A，做一下操作：

1. 删除缓存

2. 更新数据库

3. **睡眠一段时间**

4. **再次删除缓存**

添加一个睡眠时间，主要是为了确保请求A在睡眠的时候，请求B能在这段时间内完成**从数据库读取数据，再把缺失的数据写入缓存**的操作，然后请求A睡眠完，再删除缓存。

所以请求A的睡眠时间就需要大于请求B**从数据库读取数据+写入数据**的时间。**但是这个时间不好评估**。

**所以不建议这种方案**。

#### 4. 先更新数据库再删除缓存（cache aside）

**场景**：一个是查询操作，一个是更新操作的并发，我们先更新了数据库中的数据，此时，缓存依然有效，所以，并发的查询操作拿的是没有更新的数据，但是，删除操作马上让缓存的失效了，后续的查询操作再把数据从数据库中拉出来。而不会方案3一样，后续的查询操作一直在取老的数据。如下图：

<img src="./assets/image-20230619202426780.png" alt="image-20230619202426780" style="zoom: 50%;" />



<img src="./assets/image-20230619130626072.png" alt="image-20230619130626072" style="zoom:33%;" />