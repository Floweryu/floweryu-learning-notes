## 工厂方法和简单工厂对比

**工厂方法**：定义一个用户创建对象的接口，让子类去决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。

![image-20210912213513906](https://raw.githubusercontent.com/Floweryu/typora-img/main/img/20210912213515.png)

以下面运算功能的实现为例子：

**工厂方法**

![image-20210912213943284](https://raw.githubusercontent.com/Floweryu/typora-img/main/img/20210912213945.png)

**简单工厂**

![image-20210912214050041](https://raw.githubusercontent.com/Floweryu/typora-img/main/img/20210912214051.png)

可以看出，**简单工厂模式最大有点在于工厂类中做出了必要的逻辑判断，可以根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了具体产品的依赖。**就如计算器，让客户端不管使用哪个示例，只要把+给工厂，工厂会自动给出相应的实例，客户端只需要去做运算即可，不同的实例做不同的运算。

但是，有一个麻烦，如果说需要再添加一种运算方法，就必须要给工厂类添加一个`case`判断选择实例。这样不仅对外部开放，也对内部修改开放，违背了**开放-封闭原则**。

而对于工厂方法来说，假如需要添加一种运算类，只需要增加此功能的运算类和工厂类即可，这样整个工厂体系都没有修改，只是扩展了变化，完全符合**开放-封闭原则**。

**总结**：

工厂方法模式在实现时，客户端需要决定实例化哪一个工厂来实现运算类，选择判断的问题还是存在。也就是说，工厂方法把简单工厂的内部逻辑判断移到了客户端代码来进行。要想增加功能，本来是要改工厂类的，现在是修改客户端。