动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更加灵活。

<img src="https://raw.githubusercontent.com/Floweryu/typora-img/main/img/20210907204530.png" alt="image-20210907204514381"  />

## 源码

**抽象构件角色**

```java
public interface Component {
    
    public void operation();
    
}
```

**具体构件角色**

```java
public class ConcreteComponent implements Component {

    @Override
    public void operation() {
        // 写相关的业务代码
    }

}
```

**装饰角色**

```java
public class Decorator implements Component{
    private Component component;
    
    public Decorator(Component component){
        this.component = component;
    }

    @Override
    public void operation() {
        // 委派给构件
        component.operation();
    }
    
}
```

**具体装饰角色**

```java
public class ConcreteDecoratorA extends Decorator {

    public ConcreteDecoratorA(Component component) {
        super(component);
    }
    
    @Override
    public void operation() {　　　　　
        super.operation();
        // 写相关的业务代码
    }
}

public class ConcreteDecoratorB extends Decorator {

    public ConcreteDecoratorB(Component component) {
        super(component);
    }
    
    @Override
    public void operation() {　　　　  
        super.operation();
        // 写相关的业务代码
    }
}
```

## 使用示例

> 咖啡是一种饮料，咖啡店现在要卖各种口味的咖啡，如果不使用装饰模式，那么在销售系统中，各种不一样的咖啡都要产生一个类，如果有4种咖啡豆，5种口味，那么将要产生至少20个类（不包括混合口味），使用装饰模式可以减少类。



## 参考连接：

- https://www.cnblogs.com/java-my-life/archive/2012/04/20/2455726.html

