定义一个操作中的算法的骨架，将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

优点：

- 封装了不变的部分，拓展可变部分。把不可变的部分封装到父类中实现，把可变的部分由子类进行扩展。
- 在父类中提取了公共部分的代码，便于代码复用
- 部分代码是由子类实现的，可以通过子类增加相应的功能，符合开闭原则

缺点：

- 对每个不同的实现需要定义一个子类，会导致类个数增加
- 父类抽象方法由子类实现，代码阅读困难

**示例代码**：

定义一个抽象类，模板方法以`final`修饰：

```java
public abstract class Game {

    abstract void initializeGame();

    abstract void startGame();

    abstract void endGame();

    public final void playOneGame() {
        initializeGame();
        startGame();
        endGame();
    }
}
```

定义一个实现类，实现模板类中的方法：

```java
public class ChildGame extends Game{

    @Override
    void initializeGame() {
        System.out.println("初始化游戏.....");
    }

    @Override
    void startGame() {
        System.out.println("开始游戏.....");
    }

    @Override
    void endGame() {
        System.out.println("结束游戏.....");
    }

}
```

测试方法：

```java
public class TemplateTest {
    @Test
    public void mainTest() {
        Game game = new ChildGame();
        game.playOneGame();
    }
}
```

