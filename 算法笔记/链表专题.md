## 92. 反转链表 II

> 给你单链表的头指针 `head` 和两个整数 `left` 和 `right` ，其中 `left <= right` 。请你反转从位置 `left` 到位置 `right` 的链表节点，返回 **反转后的链表** 。
>
> ![img](./assets/rev2ex2.jpg)
>
> ```
> 输入：head = [1,2,3,4,5], left = 2, right = 4
> 输出：[1,4,3,2,5]
> ```
>
> ```
> 输入：head = [5], left = 1, right = 1
> 输出：[5]
> ```

### 题解：穿针引线

思路很简单，分两步：

<img src="./assets/image-20230328124651700.png" alt="image-20230328124651700" style="zoom:50%;" />

1. 先将区间部分链表反转
2. 把`pre.next`的`next`指向反转以后的链表头结点，把反转以后的链表尾结点 `next`指针指向`succ`。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        ListNode header = new ListNode(-1);
        header.next = head;
        
        ListNode pre = header;
        // 寻找到left的前一个节点
        for (int i = 0; i < left - 1; i++) {
            pre = pre.next;
        }
        
        ListNode rightNode = pre;
        for (int i = left; i <= right; i++) {
            rightNode = rightNode.next;
        }
        
        // 记录区间左节点
        ListNode leftNode = pre.next;
        // 记录区间右节点
        ListNode tailNode = rightNode.next;
        // 切断链表关系
        pre.next = null;
        rightNode.next = null;
        
        reverseLink(leftNode);
        
        // 经过反转后, rightNode变成了头结点
        pre.next = rightNode;
        // 尾结点变成了头结点
        leftNode.next = tailNode;
        return header.next;
    }
    
    public void reverseLink(ListNode head) {
        ListNode pre = null;
        ListNode cur = head;
        while (cur != null) {
            // 先将下一个节点保存
            ListNode next = cur.next;
            // 当前节点的next指向尾结点
            cur.next = pre;
            // pre指向当前节点, 作为尾结点
            pre = cur;
            // 当前指针后移一个节点
            cur = next;
        }
    }
}
```

