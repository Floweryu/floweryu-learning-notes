## 92. 反转链表 II

> 给你单链表的头指针 `head` 和两个整数 `left` 和 `right` ，其中 `left <= right` 。请你反转从位置 `left` 到位置 `right` 的链表节点，返回 **反转后的链表** 。
>
> ![img](./assets/rev2ex2.jpg)
>
> ```
> 输入：head = [1,2,3,4,5], left = 2, right = 4
> 输出：[1,4,3,2,5]
> ```
>
> ```
> 输入：head = [5], left = 1, right = 1
> 输出：[5]
> ```

### 题解：穿针引线

思路很简单，分两步：

<img src="./assets/image-20230328124651700.png" alt="image-20230328124651700" style="zoom:50%;" />

1. 先将区间部分链表反转
2. 把`pre.next`的`next`指向反转以后的链表头结点，把反转以后的链表尾结点 `next`指针指向`succ`。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        ListNode header = new ListNode(-1);
        header.next = head;
        
        ListNode pre = header;
        // 寻找到left的前一个节点
        for (int i = 0; i < left - 1; i++) {
            pre = pre.next;
        }
        
        ListNode rightNode = pre;
        for (int i = left; i <= right; i++) {
            rightNode = rightNode.next;
        }
        
        // 记录区间左节点
        ListNode leftNode = pre.next;
        // 记录区间右节点
        ListNode tailNode = rightNode.next;
        // 切断链表关系
        pre.next = null;
        rightNode.next = null;
        
        reverseLink(leftNode);
        
        // 经过反转后, rightNode变成了头结点
        pre.next = rightNode;
        // 尾结点变成了头结点
        leftNode.next = tailNode;
        return header.next;
    }
    
    public void reverseLink(ListNode head) {
        ListNode pre = null;
        ListNode cur = head;
        while (cur != null) {
            // 先将下一个节点保存
            ListNode next = cur.next;
            // 当前节点的next指向尾结点
            cur.next = pre;
            // pre指向当前节点, 作为尾结点
            pre = cur;
            // 当前指针后移一个节点
            cur = next;
        }
    }
}
```

## 25. K 个一组翻转链表

> https://leetcode.cn/problems/reverse-nodes-in-k-group/
>
> 给你链表的头节点 `head` ，每 `k` 个节点一组进行翻转，请你返回修改后的链表。
>
> `k` 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 `k` 的整数倍，那么请将最后剩余的节点保持原有顺序。
>
> 你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。
>
> <img src="./assets/image-20230328210057463.png" alt="image-20230328210057463" style="zoom:50%;" />
>
> ```
> 输入：head = [1,2,3,4,5], k = 2
> 输出：[2,1,4,3,5]
> ```
>
> <img src="./assets/image-20230328210121946.png" alt="image-20230328210121946" style="zoom:50%;" />
>
> ```
> 输入：head = [1,2,3,4,5], k = 3
> 输出：[3,2,1,4,5]
> ```

### 题解：寻找区间后反转区间链表

**思路**：

- 初始需要两个变量`pre`和`end`：`pre`记录每次需要反转链表的前一个节点，`end`记录每次反转链表的尾结点。
- 

```java
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        if (head == null || head.next == null) {
            return head;
        }
        // 构建一个假节点
        ListNode dummy = new ListNode(-1);
        dummy.next = head;
        
        // 指向每次要反转链表的头结点的上一个节点
        ListNode pre = dummy;
        // 指向每次要反转链表的尾结点
        ListNode end = dummy;
        while (end.next != null) {
            // 循环k次, 找到需要反转的链表的结尾, 需要判断end是否为空, 不然end.next会报错
            for (int i = 0; i < k && end != null; i++) {
                end = end.next;
            }
            // end为null则说明反转的链表的节点数小于k, 不执行反转
            if (end == null) {
                break;
            }
            
            // 记录需要反转的链表的下一个节点
            ListNode next = end.next;
            // 断开要反转的链表
            end.next = null;
            // 记录要反转的链表的头结点
            ListNode start = pre.next;
            // 反转链表, pre.next指向反转后的链表
            pre.next = reverse(start);
            // 反转后, 原来的链表头结点变成了尾结点, 需要链接到之前的next
            start.next = next;
            // pre和end指向下一次要反转链表的前一个节点
            pre = start;
            end = start;
        }
        return dummy.next;
    }
    
    public ListNode reverse(ListNode head) {
        ListNode cur = head;
        ListNode pre = null;
        while (cur != null) {
            ListNode next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
}
```

