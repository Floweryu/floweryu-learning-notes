线程的实现可以分两类：**用户级线程**，**内核级线程**和混合式线程。

# 1. 用户级线程

- **用户线程在用户空间中实现**，内核并没有直接对用户线程进程调度，内核的调度对象和传统进程一样，还是进程（用户进程）本身，内核并不能看到用户线程，内核并不知道用户线程的存在。
- **不需要内核支持而在用户程序中实现的线程**，其不依赖于操作系统核心，应用进程利用线程库提供创建、同步、调度和管理线程的函数来控制用户线程。
- 内核资源的分配仍然是按照进程（用户进程）进行分配的；各个用户线程只能在进程内进行资源竞争。
- **用户级线程内核的切换由用户态程序自己控制内核切换**（通过系统调用来获得内核提供的服务）,不需要内核干涉，少了进出内核态的消耗，但不能很好的利用多核CPU。
- **每个用户线程并不具有自身的线程上下文**。因此，就线程的同时执行而言，任意给定时刻每个进程只能够有一个线程在运行，而且只有一个处理器内核会被分配给该进程。

**优点**：

线程的切换无需陷入内核，故切换开销小，速度非常快；

**缺点**：

- 系统调用的阻塞问题：对应用程序来讲，同一进程中只能同时有一个线程在运行，一个线程的阻塞将导致整个进程中所有线程的阻塞；
- 由于这里的处理器时间片分配是以进程为基本单位，所以每个线程执行的时间相对减少。

# 2. 内核级线程

- 内核线程又称为守护进程，内核线程的调度由内核负责，一个内核线程处于阻塞状态时不影响其他的内核线程，因为其是调度的基本单位。这与用户线程是不一样的；
- 这些线程可以在全系统内进行资源的竞争；
- 内核空间内为每一个内核支持线程设置了一个线程控制块（TCB），内核根据该控制块，感知线程的存在，并进行控制。在一定程度上类似于进程，只是创建、调度的开销要比进程小。
- 内核线程切换由内核控制，当线程进行切换的时候，由用户态转化为内核态。切换完毕要从内核态返回用户态，即存在用户态和内核态之间的转换，比如多核cpu，还有win线程的实现。

**优点**

- 在多处理器系统中，内核能够同时调度同一进程中多个线程并行执行到多个处理器中；
- 如果进程中的一个线程被阻塞，内核可以调度同一个进程中的另一个线程；
- 内核支持线程具有很小的数据结构和堆栈，线程的切换比较快，切换开销小；
- 内核本身也可以使用多线程的方式来实现。

**缺点**

即使CPU在同一个进程的多个线程之间切换，也需要陷入内核，因此其速度和效率不如用户级线程。

