#### 一、首次适应算法（First Fit——FF）

###### 算法思想：
每次都从低地址查找，找到第一个能满足大小的空闲分区。
###### 如何实现：

 - **空闲分区以地址递增的顺序排列**
 - 每次分配内存时从低地址顺序查找空闲分区链（空闲分区表）
 - 找到大小能满足要求的第一个空闲分区
 - 每次分配完成后修改空闲分区的大小
 - 当找不到满足要求的空闲分区时，内存分配失败
###### 优点：
 - 优先利用内存中的低址部分，保留高址部分的大空闲区，为以后到达的大作业分配大的内存空间创造了条件
###### 缺点：
 - 低地址部分会产生大量的难以利用的碎片。

#### 二、循环首次适应算法（Next Fit——NF）
**与首次适应算法的不同**：

 - 在为进程寻找内存空间时，**不再是每次都从链首开始查找，而是从上次找到的空闲分区的下一个空闲分区开始查找**。
 - 如果最后一个空闲分区不能满足要求，应返回到第一个空闲分区。
###### 实现：
将空闲区链表首尾相连形成环形，每次查找从上一次停留的位置开始。
###### 优点：

 - 使内存中的空闲分区分布的更加均匀
###### 缺点：
 - 碎片仍没有得到解决
 - 大的空闲区被分配，缺乏大的空闲分区

#### 三、最佳适应算法（Best Fit——BF）
###### 算法思想：
每次分配时优先使用最小的连续空闲区。
###### 实现：

 - **空闲分区按容量递增的次序链接**
 - 每次分配空闲分区时按顺序查找空闲分区链（空闲分区表）
 - 找到满足大小要求的第一个空闲分区
 - 空闲分区分配后要更新空闲分区连（空闲分区表），保持容量递增
###### 缺点：
 - 每次都选择最小空闲分区分配，因此会留下很多、很小、难以利用的内存块。

#### 四、最坏适应算法（Worst Fit——WF）
###### 算法思想：
每次分配时优先使用最大的连续空闲区。
###### 实现：
 - **空闲分区按容量递减的顺序链接**
 - 每次分配内存时顺序查找空闲分区连（空闲分区表）
 - 找到大小满足的第一个空闲分区。
 - 空闲分区分配后要更新空闲分区连（空闲分区表），**保持容量递减**
###### 缺点：
 - 大的连续空闲分区被用完，以后的大作业没有分区使用
###### 优点：
 - 查询效率高
#### 五、快速适应算法（Quick Fit）
###### 算法思想：
将空闲分区根据其容量大小进行分类，对于每一类具有相同的所有空闲分区，单独设置一个空闲分区表，所以系统中存在多个空闲分区表。同时，还要设立一张管理索引表，每一个索引表项对应一种空闲分区，并记录该类型空闲分区的链表表头指针。
###### 搜索步骤：
 - 根据进程的长度，从索引表中找到能容纳它的最小空闲区链表
 - 从链表中取下第一块进行分配（因为一张链表的空闲区大小是一样的）
###### 优点：
 - 不会对任何空闲区进行分割，所以不会产生碎片。
 - 能保留大的空闲分区
 - 查找效率高
###### 缺点：
 - 在回收时复杂，开销大，以空间换取时间。

#### 六、伙伴系统（Buddy System）
###### 算法思想：
无论已分配分区还是空闲分区，大小均是 2 的 k 次幂。在系统开始运行时，整个内存区是一个大小为 2^m^ 的空闲区。在运行过程中根据需要，把这个空闲区分割成若干个不连续的空闲区。把大小相同的空闲分区，单独设立一个空闲分区双向链表。

###### 搜索过程：
当分配一个长度为 n 的存储空间时，首先计算 i 值，使得 2^i-1^ < n < = 2^i^，然后再空闲分区大小为 2^i^ 的空闲分区链表中查找。找到就把空闲分区分配给进程。否则，表示 2^i^ 的空闲分区已经耗尽。则在 2^i+1^ 的空闲分区链表里查找。若存在，则**把该分区分为相等的两个 2^i^的分区**，这两个分区称为一对伙伴，一个分区用于分配，另一个分区加入大小为 2^i^的空闲分区链表中。依次类推，把大的空闲分区分成所需要的大小的若干块。

###### 特点：
分配和回收的时间性能取决于查找空闲分区的位置和分割、合并空闲分区所花费的时间。

#### 六、哈希算法
###### 算法思想：
利用哈希快速查找的优点，建立哈希函数，**构造一张以空闲分区大小为关键字的哈希表**，该表的每一个表项记录一个对应的空闲分区链表头指针。
也就是在前面算法的基础上优化了**寻找空闲分区**的算法。

###### 分配过程：
当进行空闲分区分配时，根据所需空闲分区的大小，通过哈希函数计算，得到相应的空闲分区链表。

